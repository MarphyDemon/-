# 不可不知的设计模式

## 概念

设计模式是一个比较宏观的概念，它是开发者在软件过程中总结提炼出来对于某种场景的解决方案。当然在编写代码的过程中，也可以不使用设计模式。但是我们不可忽略设计模式能够带给我们更简单易懂的逻辑，更高效的代码组合方式、可维护性及易读性。作为前端开发人员，了解常用的设计模式是必需的。

## 设计模式的基本准则及其优缺点

设计模式并不是随意拍板即可决定的，它遵循这一定的基本准则，通过这些规则才能更好地保证模式的可维护性。没有最完美的设计模式，只有更适用于当前业务场景的设计模式。在学习设计模式之前，先了解不同的基本准则带给我们的优缺点。

### 单一职责原则

一个对象或函数只做一件事。降低复杂度。

> 优点:降低代码的复杂度，将代码拆分为小颗粒，易于理解
> 缺点:提升了编码难度

### 开闭原则

一个实体，如类、模块和函数应该对外扩展开放，对修改关闭。

> 优点：提高系统的可复用性和可维护性
> 缺点：容易引起类爆炸（类特别多)

### 里式替换原则

所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类对象可以替换其父类对象，而程序执行效果不变。便于构建扩展性更好的系统。

> 优点： 1.子类拥有父类的所有方法和属性，提高了代码的可复用性。 2.提高了代码的扩展性，子类不但拥有了父类的所有功能，还可以添加自己的功能。
> 缺点： 1.继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法。 2.降低了代码的灵活性。因为继承时，父类会对子类有一种约束。 3.增强了耦合性。当需要对父类的代码进行修改时，必须考虑到对子类产生的影响。有时修改了一点点代码都有可能需要对打断程序进行重构。

### 依赖倒置原则

上层模块不应该依赖底层模块，它们都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。这可以让项目拥有变化的能力。

> 优点:1.减少类间的耦合性，提高系统的稳定性。2.降低并行开发引起的风险。3.提高代码的可读性和可维护性。

### 接口隔离原则

多个特定的客户端接口要好于一个通用性的总接口，系统有更高的灵活性。

> 优点:1.将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 2.接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。 3.如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。 4.使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 5.能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。

### 最少知识原则

在涉及你程序时，尽量减少对象之间的交互。如果两个对象之间不必彼此通信，那就不要有直接的相互联系。通产引入第三者来解决这类问题。

> 优点：降低对象间的耦合性，提高复用性
> 缺点：需要封装第三者来处理联系，有时第三者会复杂到难以维护

## 设计模式的种类

### 创建型模式

一般用于创建对象。
包括：单例模式,工厂方法模式,抽象工厂模式,建造者模式,原型模式。

### 结构型模式

重点为“继承”关系，有着一层继承关系，且一般都有“代理”。
包括：适配器模式,桥接模式,组合模式,装饰器模式,外观模式,享元模式,代理模式,过滤器模式。

### 行为型模式

职责的划分，各自为政，减少外部的干扰。
包括：命令模式，解释器模式，迭代器模式，中介者模式，备忘录模式，观察者模式，状态模式，策略模式，模板方法模式，访问者模式，责任链模式。

## 前端常见的设计模式实例

### 策略模式

策略模式在业务开发中可能常会用到，针对不同的状态展示不同的结果。常见的例如可能会通过 if...else...去进行判断对比，而通过策略模式将相同的层级封装成组合或替换的代码可大幅度减少代码量。业务中常见的场景可能会有：

```js
if (a === 1) {
  aa()
} else if (a === 2) {
  bb()
} else if (a === 3) {
  cc()
} else if (a === 4) {
  dd()
}
...
```

针对不同的状态执行不同的函数，如果 else if 过多，代码可能变得超长无比，例如在接口状态中可能会返回多种情况需要进行处理。再来看如下代码。

```js
const res = {
  code_1: aa,
  code_2: bb,
  code_3: cc,
  code_4: dd,
  ...
}
res[`code_${a}`]()
```

通过参数相同，状态不同执行不同的处理，将其作为对象，key 值可采用字符串+状态组合的方式，value 作为要执行的处理，在调用过程中可采用统一处理，即交给上文中的 res 对象去判断根据状态匹配对应的逻辑。

可以看到策略模式的优点如下：简化代码，使得代码思路更清晰，增强代码可读性；避免多重条件语句；提高可复用性。而缺点也相对更明显，针对不同的状态都需要增加对应的处理，耦合性更高。

### 代理模式

为一个对象提供一个替代品，方便控制访问。作为前端同学应该常常会遇到一个词“图片懒加载”，而代理模式就是图片懒加载的实现原理之一。接下来我们通过一个示例学习下代理模式（伪代码，只包含代理模式部分实现）。

```js
function createImg() {
  var img = document.createElement('img')
  document.body.appendChild(img)
  return {
    setImg: (src) => {
      img.src = src
    },
  }
}
function proxyImg(url) {
  var cimg = createImg()
  var imgUrl = 'default.png'
  cimg.setImg(imgUrl)
  var img = new Image()
  img.src = url
  img.load = function () {
    cimg.setImg(url)
  }
}
```

分析上面代码，在 createImg 中创建了一个 img 元素，将其插入页面中，返回一个对象，存在一个方法为这个存在 dom 中的元素设置 src 属性。在 proxyImg 中接受一个参数图片的 url，执行 createImg 设置默认图片，创建新的 Image，设置 src=url，在图片加载成功之后将其复制给真正的 dom 节点的 src 属性展示图片。

相似的，如图片懒加载，我们可以将真实的图片 url 设置在 img 标签的自定义属性中，当图片节点到达游览器可视区时，将其添加到 img 标签的 src 属性中，从而实现图片的懒加载。示例如下：

```js
<img data-src="https://www.*****.img">

if(show) {
  var img = document.getElementByTag('img')
  img.src = img.getAttribute('data-src')
}
```

通过代理模式，可以分解本体的职责，节约性能，例如图片懒加载，在需要展示时进行加载图片，也可以去解决本体暂时无法处理的一些内容。相应的代理模式比较重要的一点就是需要维护本体与代理之间的关系，确保两者之间的一致性。

### 观察者模式

观察者模式，例如 vue2.0 的核心，通过 Object.defineProperty,监听如果数据改变调用 set 方法时，调用 callback，观察者模式，一次封装可以多次监听，调用处都必须使用 Observer
主要由目标和观察者组成

### 发布订阅模式

## 总结
