# react

## 怎么理解 react hook？有什么限制？hook 闭包陷阱？

hook 是 react 16.8 引入的新的特性，可以在不使用类 class 的情况下使用 state 和其他 react 特性。

hook 解决的问题：

1）在使用类组件时，我们如果需要在多个组件之间复用状态逻辑，需要借助 hoc 高阶组件来实现。hook 出现后，我们可以通过自定义 hook 抽离状态逻辑，在多个组件之间复用即可。

2）类组件的复杂性问题：类组件的生命周期函数比较多，容易造成代码的复杂性和可读性差。且容易出现 this 指向问题。导致代码难以维护。hook 通过 useEffect 来解决组件的副作用，避免生命周期的复杂性。通过 useState 来管理组件状态，避免了 this 指向问题。

3）hook 还可以解决类组件的性能问题：类组件在更新时，会重新渲染整个组件树，导致性能问题。hook 通过 useMemo 和 useCallback 来优化性能，避免不必要的渲染。当然类组件也可以通过生命周期函数来优化性能，但是代码会比较臃肿。

hook 使用有什么限制：

1）只能在函数组件或自定义 hook 中使用 hook，不能在类组件或自定义函数中使用 hook。

2）hook 只能在组件最顶层调用，不能在循环、条件判断或嵌套函数中调用 hook。hook 的执行顺序自上而下，不能改变，每次都必须执行到，在判断内会导致 hook 的执行顺序不一致，导致 react 无法正确的管理 hook 的状态。

react hook 的闭包陷阱：

在 react 中不当使用 hook，可能会导致闭包的产生，获取到的是变量定义时作用域的值。无法获取到更新之后的值。常见于异步操作中。

1. 在 useEffect 无依赖时调用过时的状态。解决方案：useEffect 增加依赖。

2. 在事件响应函数中调用过时的状态。解决方案：使用 useRef，在事件响应函数中使用 ref.current。

## react HOC 高阶组件

react 高阶组件是一个函数，接受一个组件作为参数，返回一个新的组件。高阶组件主要用于封装一些公共逻辑，例如权限控制、数据请求、路由跳转等。高阶组件可以实现代码复用，避免重复代码，提高代码的可维护性。
高阶组件的使用场景：
1）权限控制：根据用户的权限判断是否渲染某个组件。
2）数据请求：在组件加载时请求数据，并将数据传递给子组件。
3）路由跳转：根据路由参数判断是否渲染某个组件。
4）事件处理：封装一些公共的事件处理逻辑，例如点击事件、输入事件等。
5）性能优化：通过 shouldComponentUpdate 或 PureComponent 来优化性能，避免不必要的渲染。
6）状态管理：通过高阶组件来管理组件的状态，例如 redux、mobx 等状态管理库。

## react 性能优化

1）componentShouldUpdate 通过判断值是否改变进行性能优化。
2）useMemo、useCallback 进行性能优化，useMemo 主要判断依赖是否更新，依赖更新时，重新计算结果触发二次渲染。useCallback 主要用于缓存函数，依赖更新时才会创建新的函数。
3）代码拆分和懒加载：通过 split 分割代码，按需加载，react.lazy。
4）长列表优化：通过加载展示可视区的内容，优化长列表性能。可接入第三方库。
5）合理使用 react 的 key，避免使用 index 作为 key。使用 index 作为 key 在元素增删时会导致 react 无法正确识别元素内容的更新，造成状态混乱。
6）减少不必要的请求或批量请求合并。
7）PureComponent 也可以被用来做性能优化。PureComponent 纯组件，会自动帮我们浅对比 state 和 props，在有变更时才会重新渲染。有一个缺点就是需要保证 PureComponent 的子组件也必须是纯组件，否则子组件可能会不被更新导致展示异常。

## 受控组件和非受控组件

受控组件：input 的 value 受代码控制。
非受控组件：input 无 value，只有 onChange。

这里可以讲讲 2.0 小程序下单页由受控组件改为非受控组件的过程。
背景是：下单页需要填写手机号、送餐时间、备注、餐具等信息。该类信息不参与算价，需要在提单时传递到后端。
前期在下单页实体内定义上述状态数据。该逻辑会存在以下问题：
1）变量定义繁琐，有变动，需要同时修改实体文件及模块或组件。
2）以上数据可能存在后端下发的场景，需要在组件内接收到值后，再去通知实体记录状态。
3）用户手动变更后，也需要事件通知实体更新。

后期更改为组件内自己维护，组件内提供一个 exportData 方法，在提单时，实体内调用 collectData 方法，收集不同模块及组件内的表单值，传递给后端。
这样做的优势就是简化了实体内维护多个变量的复杂度。如变量有增删时，只需要修改组件内部的状态及 exportData 即可。

## react 合成事件

react 基于游览器的事件机制，实现了一套自身的事件机制。包括事件冒泡、事件派发等。这个称之为 react 的合成事件。

react 中事件的执行机制如下：
原生事件：子元素 dom 事件监听
原生事件：父元素 dom 事件监听
react 事件：子元素 dom 事件监听
react 事件：父元素 dom 事件监听
原生事件：document dom 事件监听。

结论如下：react 所有事件都挂在 document 上。所以当真实的 dom 事件发生后，会先执行原生事件，然后冒泡到 document 对象后，再执行 react 事件。最后真正执行 document 上挂载的事件。

react 能够减少内存开销的原因就是 react 事件都挂载在 document 上，并非挂载每个 dom 上。

## jsx 和 js 有什么区别？

jsx 是 react 提供的一种语法糖，允许开发者在 jsx 内同时编写 html 和 原生 js。jsx 需要通过 webpack，babel 之类的工具转换为 js。jsx 的本质就是 react.createElement。
js 可以直接打包，不需要额外转换。

## setState 的异步性

在 react 中，setState 是异步的，这是 react 性能优化的考量结果。多次 setState 会合并为一次执行。react 中也有 setState 的批处理机制。

setState 后，不能立即拿到结果，在回调函数或者 componentDidUpdate 中可以拿到更新后的结果。

setState 在 setTimeout 或者原生事件中是同步的。setTimeout 是宏任务，此时 react 批处理时机已经过去。而在原生事件中，由于合成事件原因，会先执行原生事件，再冒泡到 document 中，执行挂在的实际方法。所以此时也是同步的。

## 如何理解 react fiber 架构

react fiber 架构是对 react 核心算法的一次重大升级。主要用于解决 react 的性能问题。react 前期方案是状态变更之后，通过 diff 对比，更新全量的节点，然后一次性渲染。

通过 fiber 主要实现了两件事：
1）fiber 节点。fiber 节点包含组件的状态、类型等所有信息，fiber 节点通过链表的形式链接在一起，取代了传统的虚拟 dom 树。这种链表结构使得 react 可以更灵活的处理节点，实现任务的暂停、恢复和优先级调度。
2）任务切片。fiber 通过任务切片将渲染任务分割成一个个小任务，这些任务执行时间比较短。执行完成后去判断是否有更高优先级的任务，比如点击事件等，存在高优先级的任务时，会将主线程交由游览器去处理。等待处理结束后再去继续执行渲染任务。

工作原理：

调度阶段：负责任务的优先级排序和任务调度。
调和阶段：负责对比新旧 fiber 树，找出需要更新的地方。和传统方式对比，该阶段是可以被中断的。
提交阶段：将新的 fiber 树一次性提交，批量更新 dom。此时也会执行一些与 dom 相关的副作用操作，例如添加事件监听器，更新 refs。
